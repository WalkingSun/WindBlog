---
layout: blog
title: Go Map
categories: [Go, 知识点]
description: 熟悉
keywords: Go
cnblogsClass: \[Markdown\],\[随笔分类\]Go
oschinaClass: \[Markdown\]
csdnClass: \[Markdown\]
163Class: \[Markdown\]
51ctoClass: \[Markdown\]
chinaunixClass: \[Markdown\]
sinaClass: \[Markdown\]
---

# map
map使用散列表（hash）实现

### 添加关联到map并访问关联和数据
map[Key_Type]Value_Type

```go
scene := make(map[string]int)
scene["route"] = 66
fmt.Println(scene["route"])
v :=scene["route2"]    //尝试查找一个不存在的键，返回的将是value_type的默认值
fmt.Println(v)

/**
66
0
*/
```

填充内容方式
```go
m := map[string]string{
    "W": "forward",
    "A": "left",
    "D": "right"
}
```
并没有使用make，而是使用大括号进行内容定义，就像json格式一样，健值对，并使用逗号分割。

### 取值
```go
m = map[string]int{}
i := m["route"]

```
如果route存在，就返回那个值，如果不存在，返回0值，也就是说，根据这个value的类型，返回缺省值，比如string，就返回“”，int 就返回0

###  判断map中key是否存在
```go
if _, ok := map[key]; ok {
//存在
}
```

```go
    m := make(map[string]string)
	m["b"] = "1"
	val,exist := m["a"]
	val1,exist1 := m["b"]
	fmt.Println(val,exist)
	fmt.Println(val1,exist1)
//	 false
//    1 true

```

### delete()从map中删除健值对
```go
delete(map, 键)
//map 要删除的实例
```

### 清空map中的所有元素
清空map的唯一办法就是重新make一个新的map。
不用担心垃圾回收的效率，Go中的并行垃圾回收效率比写一个清空函数高效的多。

### 能够在并发环境中使用的map——sync.Map
Go中的map在并发环境下，只读是线程安全的，同时读写线程不安全。
```go
package main

func main() {
	m := make(map[int]int)
	// 并发情况下读写 map 时
	go func(){
		// 不停地对map进行写入
		for {
			m[1] = 1
		}
	}()

	go func(){
		// 不停地对map进行读取
		for {
			_ = m[1]
		}
	}()

	// 无限循环, 让并发程序在后台执行
	for {
		_:
	}
}
```

出现错误： fatal error: concurrent map read and map write

使用sync.map （对key加锁）
```go
package main

import (
	"fmt"
	"sync"
)

func main() {
	m := sync.Map{}
	// 并发情况下读写 map 时
	go func(){
		// 不停地对map进行写入
		for {
			m.Store(1,1)
		}
	}()

	go func(){
		// 不停地对map进行读取
		for {
			_,err := m.Load(1)
			fmt.Println(err)
		}
	}()

	// 无限循环, 让并发程序在后台执行
	for {
		_:
	}
}
```
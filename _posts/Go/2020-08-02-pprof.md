---
layout: blog
title: Go 调试
categories: [Go, 知识点]
description: 熟悉
keywords: Go
cnblogsClass: \[Markdown\],\[随笔分类\]Go
oschinaClass: \[Markdown\]
csdnClass: \[Markdown\]
163Class: \[Markdown\]
51ctoClass: \[Markdown\]
chinaunixClass: \[Markdown\]
sinaClass: \[Markdown\]
---

# pprof
## web
```
package main

import (
    "encoding/json"
    "fmt"
    "net/http"
    _ "net/http/pprof"
    "time"
)

func main() {
    go func() {
        for {
            fmt.Println(1111)
        }
    }()

    fmt.Println("start api server...")
    panic(http.ListenAndServe(":6060", nil))
}
```

pprof web界面:
http://localhost:6060/debug/pprof/

-   cpu（CPU Profiling）: `$HOST/debug/pprof/profile`，默认进行 30s 的 CPU Profiling，得到一个分析用的 profile 文件
-   block（Block Profiling）：`$HOST/debug/pprof/block`，查看导致阻塞同步的堆栈跟踪
-   goroutine：`$HOST/debug/pprof/goroutine`，查看当前所有运行的 goroutines 堆栈跟踪
-   heap（Memory Profiling）: `$HOST/debug/pprof/heap`，查看活动对象的内存分配情况
-   mutex（Mutex Profiling）：`$HOST/debug/pprof/mutex`，查看导致互斥锁的竞争持有者的堆栈跟踪
-   threadcreate：`$HOST/debug/pprof/threadcreate`，查看创建新 OS 线程的堆栈跟踪

交互终端
```shell
go tool pprof [http://localhost:6060/debug/pprof/profile?seconds=60
```

## 使用生成火焰图
查看cpu情况
```bash
go tool pprof -http=:8081 -seconds 10  http://localhost:6060/debug/pprof/profile
```

打开空不要慌，/ui

http://127.0.0.1:8081/ui/flamegraph?si=cpu 查看cpu时长


主要模块：
- runtime.mcall 系统调度
	- runtime.goexit0  会重新调用 runtime.schedule 触发新一轮的 Goroutine 调度，Go 语言中的运行时调度循环会从 runtime.schedule 开始，最终又回到 runtime.schedule
	- runtime.systemstack 



#### 

# 参考 

https://pkg.go.dev/net/http/pprof

https://juejin.cn/post/6844903680232144910

https://zhuanlan.zhihu.com/p/71529062

https://eddycjy.com/posts/go/tools/2018-09-15-go-tool-pprof/

# prometheus  metrics











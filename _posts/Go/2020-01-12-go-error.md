---
layout: blog
title: Go error
categories: [Go, 知识点]
description: 熟悉
keywords: Go
cnblogsClass: \[Markdown\],\[随笔分类\]Go
oschinaClass: \[Markdown\]
csdnClass: \[Markdown\]
163Class: \[Markdown\]
51ctoClass: \[Markdown\]
chinaunixClass: \[Markdown\]
sinaClass: \[Markdown\]
---

# 返回error
```go
errors.New("出现错误")
```

# error获取字符串
```go
errors.error()
```

# 返回error（错误拼接）
```go
# 错误拼接
fmt.Errorf("not found mongodb config: %s", "出现错误")
```

Errorf函数源码：
```go
// a参数是一个interface，可以接收任意类型
func Errorf(format string, a ...interface{}) error {
	p := newPrinter()
	p.wrapErrs = true
	p.doPrintf(format, a)
	s := string(p.buf)
	var err error
	if p.wrappedErr == nil {
		err = errors.New(s)
	} else {
		err = &wrapError{s, p.wrappedErr}
	}
	p.free()
	return err
}
```

# error多个情况
```go
multierror.Append()
```

## errgroup 并发执行
https://linuxhint.com/golang-errgroup/

# log包
log模块主要提供了3类接口。分别是 “Print 、Panic 、Fatal ”，对每一类接口其提供了3中调用方式，分别是 "Xxxx 、 Xxxxln 、Xxxxf"，基本和fmt中的相关函数类似
```go
package main

import (
    "log"
)

func main(){
    arr := []int {2,3}
    log.Print("Print array ",arr,"\n")
    log.Println("Println array",arr)
    log.Printf("Printf array with item [%d,%d]\n",arr[0],arr[1])
}
程序输出结果：

2016/12/15 19:46:19 Print array [2 3]
2016/12/15 19:46:19 Println array [2 3]
2016/12/15 19:46:19 Printf array with item [2,3]
```

- 对于 log.Fatal 接口，会先将日志内容打印到标准输出，接着调用系统的 os.exit(1) 接口，退出程序并返回状态 1 。但是有一点需要注意，由于是直接调用系统接口退出，defer函数不会被调用

- 对于log.Panic接口，该函数把日志内容刷到标准错误后调用 panic 函数;

- 也可以自定义Logger类型， log.Logger提供了一个New方法用来创建对象：

```func New(out io.Writer, prefix string, flag int) *Logger```
该函数一共有三个参数：

（1）输出位置out，是一个io.Writer对象，该对象可以是一个文件也可以是实现了该接口的对象。通常我们可以用这个来指定日志输出到哪个文件。
（2）prefix 我们在前面已经看到，就是在日志内容前面的东西。我们可以将其置为 "[Info]" 、 "[Warning]"等来帮助区分日志级别。
（3） flags 是一个选项，显示日志开头的东西，可选的值有
```go
 Ldate         = 1 << iota     // 形如 2009/01/23 的日期
 
 Ltime                         // 形如 01:23:23   的时间
 
 Lmicroseconds                 // 形如 01:23:23.123123   的时间
 
 Llongfile                     // 全路径文件名和行号: /a/b/c/d.go:23 
 
 Lshortfile                    // 文件名和行号: d.go:23
 
 LstdFlags     = Ldate | Ltime // 日期和时间
```
 
```go
package main
import (
    "log"
    "os"
)
func main(){
    fileName := "Info_First.log"
    logFile,err  := os.Create(fileName)
    defer logFile.Close()
    if err != nil {
        log.Fatalln("open file error")
    }
    debugLog := log.New(logFile,"[Info]",log.Llongfile)
    debugLog.Println("A Info message here")
    debugLog.SetPrefix("[Debug]")
    debugLog.Println("A Debug Message here ")
}
生成文件：Info_First.log
[Info]F:/works/Golang/src/awesomeProject/main/main.go:57: A Info message here
[Debug]F:/works/Golang/src/awesomeProject/main/main.go:59: A Debug Message here 
```
- [ ] 设计模式

  - [x] 单一职责原则 1
  - [x] 里氏替换 
  - [x] 依赖倒置
  - [ ] 接口隔离
  - [ ] 迪米特法则
  - [ ] 开闭原则 
  - [ ] 
  - [x] 单列模式
    - [x] 非线程安全
    - [x] 线程安全
  - [x] 工厂模式
    - [x] 简单工厂模式
    - [x] 多工厂模式
  - [ ] 抽象工厂模式
  - [ ] 观察者模式
  - [ ] 模版方法模式
  - [ ] 策略模式
  - [ ] 建造者模式
  - [ ] 代理模式
  - [ ] 原型模式
  - [ ] 中介者模式
  - [ ] 命令模式
  - [ ] 责任链模式
  - [ ] 装饰模式
  - [ ] 适配模式 
  - [ ] 迭代器模式
  - [ ]  组合模式
  - [ ]  门面模式 
  - [ ] 备忘录模式 
  - [ ] 访问者模式 
  - [ ] 状态模式 
  - [ ] 解释器模式 
  - [ ] 享元模式
  - [ ]  桥梁模式
  - [ ] 

  - [ ] 

  - [ ] 
  - [ ] 
  - [ ] 

  - [ ] 
  - [ ] 
  - [ ] 

- [ ] Go高级编程阅读  
  - [x] 生产消费模式 1
  - [x] 发布订阅模式 1
  - [x] 控制并发数 1
  - [ ] RPC
  
- [ ] Go刷题
  
  - [x] 刷一题 1
  
- [ ] kafka阅读
  - [ ] 拉勾教育 / 极客时间
  - [ ] 书籍
  
- [ ] 数据结构
  - [ ] heap
    - [x] 查询、添加
    - [x] 取出元素和Sift Down   
      - [x] coding
    - [x] Heapify和Replace
      - [x] Replace
      - [x] Heapify coding 1
    - [x] 基于堆的优先队列 1
    - [x] LeetCode上优先队列相关问题
    - [x] 和堆相关的、广义队列
  - [ ] 线段树
  - [ ] Tire
  - [ ] AVL
  
- [ ] 力扣刷题
  - [ ] https://leetcode-cn.com/leetbook/
  - [ ] https://github.com/lifei6671/interview-go



- [ ] 错题复盘系统
- [ ] 跑步锻炼
- [ ] 数据结构、数据库技术过一遍 
  - [x] 树
    - [x] 树习题温故
  - [ ] 图
  - [ ] 数据库
- [ ] 练习题刷题
  - [ ] 打印一份
- [ ] 软件设计师主观题刷一道
  - [x] 刷题5-3
  - [ ] 刷题5-4
  - [ ] 刷题5-5
- [ ] RTA策略熟悉下
  - [x] 曝光策略
  - [ ] 几个服务了解
- [x] oss存储遇到问题总结下
  - [x] 网络流量带宽
  - [x] 机器负载
  - [x] 文件服务器
- [ ] 点击优化问题确认了解下
  - [x] 逃逸
  - [ ] 全局变量，引用传递
- [ ] 实时票房技术方案整理



go的grpc原理
go的空struct的使用
channel的阻塞如何解决
go的sync.once的如何使用
go的遇到的阻塞如何解决的
go的interface的应用
go的sync.RWmutex介绍一下

GMP调度器必问

连接池参数调优 总结下

Go 语言最主要的特性：

- 自动垃圾回收
- 更丰富的内置类型
- 函数多返回值
- 错误处理
- 匿名函数和闭包
- 类型和接口
- 并发编程
- 反射
- 语言交互性







- [x] 函数计算文档完善
- [x] 试题打印
- [ ] 架构梳理思维导图
- [x] go基础补充






































---
layout: blog
title: 进程控制
categories: [服务器]
description:
keywords: 进程
cnblogsClass: \[Markdown\],\[随笔分类\]服务器
oschinaClass: \[Markdown\],服务器,日常记录
csdnClass: \[Markdown\]
163Class: \[Markdown\]
51ctoClass: \[Markdown\]
chinaunixClass: \[Markdown\]
sinaClass: \[Markdown\]
---

# 进程控制
进程是系统环境的一个基本组成部分，是系统资源的基本单位，UNIX系统中完成的工作几乎通过进程来控制。

## 进程创建
进程有一个唯一标识PID(正整数)与之关联，创建进程就会获得其PID。

系统创建时就存在的几个特殊进程：
- PID为0，swapper调度进程；
- PID为1，init进程，在系统自举过程末尾由内核创建的；
- PID为2，pagedaemon,负责支持虚拟系统的分页。

特殊的进程在0~n之间，普通用户的进程在 n+1 - MAXPID-1之间，用户PID通常比较大。

getpid()获取PID:

![image](https://raw.githubusercontent.com/WalkingSun/WindBlog/gh-pages/images/blog/TIM截图20181129175342.png)

getppid()获取调用进程的父进程。

> 应用程序创建进程的唯一方法是在执行进程中fork新进程。
![image](https://raw.githubusercontent.com/WalkingSun/WindBlog/gh-pages/images/blog/TIM截图20181129175733.png)

fork函数创建新进程，与当前进程构成父子关系。

若fork调用成功，则同时存在父进程和子进程且二者均从fork返回，但具有不同的返回值：子进程的返回值为0，而父进程返回的是子进程的PID。
fork返回的子进程的PID给父进程的原因：一个进程可以有多个子进程，因而无法通过函数获取到进程的子进程ID。fork返回0给子进程的原因因为每个子进程仅有一个父进程，子进程通过getppid()而获得父进程ID。

若调用失败，fork返回-1，并置errno指出失败原因（如EAGAIN没有足够资源用来创建进程或已经有太多进程在运行）。

当fork成功，父子进程均从fork之后一条语句继续执行，子进程几乎是父进程的复制。
1）共同特征
- 实际用户ID
- 有效用户ID
- 会晤ID
- 控制终端
- 当前工作目录
- 根目录
- 文件方式创建屏蔽
- 环境变量
- 所有相连的共享存储段
- 资源限制
- 任何打开的文件描述字的执行时关闭标志FD_CLOEXEC

2）不同点
- 子进程有自己的唯一进程ID
- 子进程拥有其父进程打开的文件描述字副本，此副本属于子进程本身，随后父进程改变其文件描述字属性不会影响到子进程，反过来也是一样。
- 子进程不继承父进程设置的文件锁
- 子进程不继承父进程设置的定时器
- 父进程的任何悬挂信号在进程中都被清除，但子进程从父进程继承他的信号屏蔽和信号动作。
- 子进程已耗费的紧凑时间tms_utime、time_stime、tms_cutime和tms_cstime均置为0

> fork函数一般在以下两种情况使用：
- 当一个进程想要复制自己以便父进程和子进程在同一时刻可以这行不同的代码段时。例如网络服务，父进程调用fork并让子进程处理请求，然后父进程返回并等待下一个服务请求到达。
- 当一个进行想要执行另一个不同的程序时，shell便是这种情况的典型用法。在这种情况下，子进程在从fork返回后不久执行一个exec函数。

第二种情况遇到资源使用效率的问题：fork调用必须给子进程创建一个逻辑上与父进程不同的地址空间。然而，由于fork返回后立即调用exec，将抛弃这空间，故复制地址空间是对资源极大的浪费。
解决此问题：
- 写复制。父进程的数据和栈空间临时成为只读的并标志为“写——复制”。子进程一开始时与父进程共享存储页。如果子进程或父进程企图修改某页，缺页中断便出现，从而UNIX内核识别出这是
一个“写——复制”页，于是复制该页成为新的可写页。这样只复制修改的页，而不是整个进程的地址空间。如果子进程调用exec或exit，这些页转换为它们原来的保护并写——复制标志被清除。
- vfork函数。类似fork，比fork效率更高。
    - vfork所创建的子进程共享其父进程的地址空间，即父进程借它的地址空间给子进程，直到子进程调用exec或exit为止。
    - vfork在出借父进程的地址空间给子进程的同时阻塞父进程，父进程悬挂执行子进程直到调用了exec或exit，此时内核返回地址空间给父进程并唤醒它。

vfork特别快，因为它无需复制地址映射表，地址空间直接通过地址映射寄存器传递给子进程。但它是一种非常危险的调用，因为它允许一个进程使用、甚至修改另一个进程的地址空间。
使用必须小心，不能让其修改任何全局数据，共享局部变量。

## 执行一个新程序
fork创建一个新进程时，所创建的子进程具有父进程的程序映象，子进程是父进程的克隆。但多数情况下，创建新进程的目的是执行一个新程序，因此子进程克隆的程序映象将以某种方式被新程序的程序映象所替代。

exec函数用于产生一个新的程序映象。
![image](https://raw.githubusercontent.com/WalkingSun/WindBlog/gh-pages/images/blog/TIM截图20181202211117.png)
6个函数具有相同的功能，都用新程序的程序映象覆盖进程原来的程序映象。新程序文件由参数path或file给出，它的程序代码将替代原来的程序代码被执行。

exec函数调用成功系统将用一个新程序的地址空间替代调用进程的地址空间并装入新程序的内容。如果调用进程由cfork创建，exec返回老的地址空间给父进程；否则它释放老的地址空间。
当exec返回时，进程从新程序（main函数）的第一条指令处开始执行。这意味成功的exec调用决不会返回，因为原来的程序空间已经被新程序的地址空间多覆盖，只有当调用失败时才返回，其返回值为-1并置errno指出错误原因。

> exec执行新程序，进程仍保持原样，只是相连的程序被替换。
新程序保持调用进程的下述属性：
- 进程ID和父进程ID；
- 实际用户ID和实际组ID；
- 附加组ID；
- 会晤期ID和进程组ID；
- 控制终端；
- 闹钟定时器中遗留的时间；
- 当前工作目录和根目录；
- 文件方式创建屏蔽；
- 文件锁；
- 进程信号屏蔽；
- 悬挂信号
- 资源限制
- tms_utime、time_stime、tms_cutime和tms_cstime之值。

新程序中发生变化属性：
- 调用进程中打开的文件描述字仍保持打开，但设置了执行并关闭标志FD_CLOSECEC的文件描述字除外。
- 调用进程打开的目录流经过exec后在新映象中被关闭；
- 在调用进程中器句柄置为默认或为忽略的信号经exec后在新映象中仍为默认或忽略。但调用进程原设置为要捕获 的信号在新映象中的句柄改为默认，并且，exec调用成功后不再保留替代
信号栈且SA_ONSTACK标志被清除。
- exec调用成功后，先前通过atexit所注册的函数不再是注册。

6个exec之间的关系：
![image](https://raw.githubusercontent.com/WalkingSun/WindBlog/gh-pages/images/blog/TIM截图20181202213703.png)

## 等待进程完成
父、子进程可以同时进行，相互之间没有等待。Shell在后台开始一新进程时采用就是这种方式。

不过这种方式并不总是希望的，父进程常常需要等待子进程执行完成后才能继续执行。下述函数用于等待进程的终止：
![image](https://raw.githubusercontent.com/WalkingSun/WindBlog/gh-pages/images/blog/TIM截图20181203100919.png)

wait和waitpid函数允许调用进程获取子进程的状态信息。

wait函数首先检查调用进程是否有任何已终止的子进程，如果有的话，它立即返回；如果没有已终止的子进程，wait阻塞调用进程直至有一个子进程终止并在此时立即返回。
如果调用进程没有任何子进程或wait由子信号而被终端，wait将返回-1并置errno支出错误。

waitpid提供wait未提供的特征：
- waitpid允许等待某个特定的子进程，而wait返回任意一个已终止进程的状态；
- waitpid提供wait的非阻塞版本；
- waitpid支持作业控制。


<!-- ## 进程终止和僵死进程 -->

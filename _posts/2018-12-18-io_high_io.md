---
layout: blog
title: 高级IO
categories: [服务器]
description:
keywords: 高级IO
cnblogsClass: \[Markdown\],\[随笔分类\]服务器
oschinaClass: \[Markdown\],服务器,日常记录
csdnClass: \[Markdown\]
163Class: \[Markdown\]
51ctoClass: \[Markdown\]
chinaunixClass: \[Markdown\]
sinaClass: \[Markdown\]
---
# 高级IO
特殊的IO操作，包括文件锁、系统V的流、信号驱动的I/O、多路转I/O（select和pull函数）、readv和writev函数以及存贮映射I/O等概念和函数。

## 文件锁
文件锁是用户、多任务操作系统中非常重要的内容。文件锁机制为多个程序访问共享的文件提供重要的安全保护手段。

UNIX系统允许多个进程同时对一个文件进行读写操作，每一个read或write调用本身是原子的，但在两个系统调用之间并没有同步。

通过文件锁，进程在操作期间，可以锁定文件中敏感的部分以防止其他进程更改这部分中的数据。

文件锁根据其访问方式，分为读锁、写锁。
- 读锁目的防止其他进程更改文件。在一个文件中设置读锁，其他进程仍可在相同部分设置读锁，但不允许设置写锁。故读锁也称为共享锁或共享读锁。
- 写锁隔离文件使它所写的内容不受其他进程干扰。在一个文件上设置写锁，不允许其他进程在相同部分再设置任何类型的锁。故写锁称为互斥锁或互斥写锁。

### fcntl文件锁操作
文件锁操作通过fcntl函数来完成。

![image](https://raw.githubusercontent.com/WalkingSun/WindBlog/gh-pages/images/blog/TIM截图20181219110619.jpg)

该函数对文件描述字fields进行操作，具体操作取决于cmd参数。当fcntl函数用于文件锁时，cmd参数使用F_GETLK、F_SETLK和F_SETLKW3个专用命令。

为了防止一把锁，程序猿需要制定锁的类型、锁在文件中开始的字节偏移以及从哪一点字节开始的字节数（管辖区域）。故，fcntl必须提供第三个参数。

![image](https://raw.githubusercontent.com/WalkingSun/WindBlog/gh-pages/images/blog/TIM截图20181219111802.jpg)

![image](https://raw.githubusercontent.com/WalkingSun/WindBlog/gh-pages/images/blog/TIM截图20181219111826.jpg)

文件锁类型：共享读锁、互斥写锁。

共享锁和互斥锁的竞争规则：

![image](https://raw.githubusercontent.com/WalkingSun/WindBlog/gh-pages/images/blog/TIM截图20181219112018.jpg)

> fcntl 三种锁命令

- F_GETLK 获取已打开文件描述字fileds给定文件的锁信息，它并不企图锁定该文件，只是查询在该文件的某个区域是否存在妨碍指定锁被创建的其他锁。锁区域由flock所指结构的l_whence、l_start和l_len成员给定，在这个区域可能会有多个锁影响心锁的创建，但fcntl函数只返回其一。
正常返回值是大于等于0的常数，失败返回-1，原因可能是参数非法。
- F_SETLK 企图在已打开的文件描述字fields上设置有flock锁描述的锁。
- F_SETLKW F_SETLK的阻塞版本，也同F_SETLK一样设置或清除一个锁，所不同的是它导致阻塞直至请求能够被完成为止。

### 锁的请求、释放和测试
在使用锁机制时，常用的操作有请求、释放及测试锁，必须首先形成适当的flock结构，然后调用fcntl函数来实际完成动作。

![image](https://raw.githubusercontent.com/WalkingSun/WindBlog/gh-pages/images/blog/TIM截图20181220113000.jpg)

文件锁的作用是防止多个进程读写同一个文件时出现数据不一致的情形。应用一般在文件中有可能被多个进程修改的部分设置文件锁，每当读写这部分数据时通过显式的置锁和解锁来保证所读数据的完整性。

### 文件锁和进程与文件的关系
1） 锁是与进程相连的，这意味着当进程终止时，它的所有锁都被释放，并且锁决不会被fork创建的子进程所继承。
如果进程在获得一把锁之后调用fork，对于fork所继承的任何文件描述字而言，子进程都必须调用fcntl获得自己的锁。这样做的作用就是防止多个进程在同一时刻写同一文件，如果子进程由fork继承锁，则父子进程能同时写一个文件（违背锁的初衷）。

锁虽然不能被子进程继承，但可以被exec执行的新程序所继承，因为exec不派生进程。

2） 锁同时也与文件相连，这意味着**当进程关闭一个文件描述字时，由此描述字所引用的文件上关于此进程的任何锁都被释放**，即使这些锁是用另外的仍然打开的文件描述字所建立的。

内核不能区分（也不关心）父进程的锁是哪一个描述字获得的，故关闭一个文件描述字同时也释放**同一文件**其他描述字获得的锁的原因。

<!-- ### 死锁 -->
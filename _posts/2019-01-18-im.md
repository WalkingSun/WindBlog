---
layout: blog
title: 浅析聊天室【draft】
categories: [PHP,Swoole,服务器]
description: 聊天室实力入坑
keywords: IM
cnblogsClass: \[Markdown\],\[随笔分类\]PHP,\[随笔分类\]网络编程,\[随笔分类\]Swoole
oschinaClass: \[Markdown\],PHP,服务器,日常记录
csdnClass: \[Markdown\]
163Class: \[Markdown\]
51ctoClass: \[Markdown\]
chinaunixClass: \[Markdown\]
sinaClass: \[Markdown\]
---

# 由来
环境：PHP7、Swoole、linux

对聊天室有点感兴趣，对于网络协议有一点一知半解，所以决定借助swoole实现个简单的聊天室，来简单剖析下原理，知道原理以后就可以考虑用其他语言或者自己造轮子写个，当然这是后话。

源码我放置github（ https://github.com/WalkingSun/SwooleServer ），有兴趣可以借鉴借鉴。

# 系统设计
即时通讯的网络通信基于长连接，通信方式有TCP、UDP、socket、websocket等，本次实现是websocket，系统建立常驻内存的websocket服务，客户端即浏览器两者建立连接通信。通信过程如下：

![image](https://raw.githubusercontent.com/WalkingSun/WindBlog/gh-pages/images/blog/im.jpg)

关于客户端连接websocket服务，本文不做细述，websocket服务的建立借助swoole，需要在服务端的open、recieve、send、close建立回调处理，为了方便我将连接的客户端信息放入swoole_table（一个基于共享内存和锁实现的超高性能，并发数据结构）。

代码仅供参考：

websocket 服务类：
```php
<?php
/**
 * Created by PhpStorm.
 * User: WalkingSun
 * Date: 2018/10/28
 * Time: 15:54
 */

class WsServer
{
    const host = '0.0.0.0';
    const port = '9501';

    public $swoole;

    public $config = ['gcSessionInterval' => 60000];

    public $openCallback;       //open回调

    public $messageCallback;    //message回调

    public $runApp;    //request回调

    public $workStartCallback;       //work回调

    public $finishCallback;     //finish回调

    public $closeCallback;       //close回调

    public $taskCallback;       //task回调

    public function __construct( $host, $port, $mode, $socketType, $swooleConfig=[], $config=[])
    {
        $host = $host?:self::host;
        $port = $port?:self::port;
        $this->swoole = new Swoole_websocket_server($host,$port,$mode,$socketType);
        $this->webRoot = $swooleConfig['document_root'];
        if( !empty($this->config) ) $this->config = array_merge($this->config, $config);
        $this->swoole->set($swooleConfig);

        $this->swoole->on('open',[$this,'onOpen']);
        $this->swoole->on('message',[$this,'onMessage']);
        $this->swoole->on('request',[$this,'onRequest']);
        $this->swoole->on('WorkerStart',[$this,'onWorkerStart']);            //增加work进程
        $this->swoole->on('task',[$this,'onTask']);            //增加task任务进程
        $this->swoole->on('finish',[$this,'onFinish']);
        $this->swoole->on('close',[$this,'onClose']);
    }

    public function run(){
        $this->swoole->start();
    }

    /**
     * 当WebSocket客户端与服务器建立连接并完成握手后会回调此函数
     * @param $serv swoole_websocket_server 服务对象
     * @param $request swoole_http_server 服务对象
     */
    public function onOpen( swoole_websocket_server $serv,  $request){
        call_user_func_array( $this->openCallback, [ $serv, $request ] );

        //定时器（异步执行）
//        if($request->fd == 1){
//            swoole_timer_tick(2000,function($timer_id){
//                echo time().PHP_EOL;
//            });
//        }
    }

    /**
     *当服务器收到来自客户端的数据帧时会回调此函数。
     * @param $server  swoole_websocket_server 服务对象
     * @param $frame  swoole_websocket_frame对象，包含了客户端发来的数据帧信息
     * $frame->fd，客户端的socket id，使用$server->push推送数据时需要用到
    $frame->data，数据内容，可以是文本内容也可以是二进制数据，可以通过opcode的值来判断
    $frame->opcode，WebSocket的OpCode类型，可以参考WebSocket协议标准文档
    $frame->finish， 表示数据帧是否完整，一个WebSocket请求可能会分成多个数据帧进行发送（底层已经实现了自动合并数据帧，现在不用担心接收到的数据帧不完整）
     */
    public function onMessage(swoole_websocket_server $serv, swoole_websocket_frame $frame ){

        call_user_func_array( $this->messageCallback, [ $serv, $frame ]);

    }

    /**
     * @param $serv  swoole_websocket_server 服务对象
     * @param $fd  连接的文件描述符
     * @param $reactorId  来自那个reactor线程
     * onClose回调函数如果发生了致命错误，会导致连接泄漏。通过netstat命令会看到大量CLOSE_WAIT状态的TCP连接
     * 当服务器主动关闭连接时，底层会设置此参数为-1，可以通过判断$reactorId < 0来分辨关闭是由服务器端还是客户端发起的。
     */
    public function onClose( swoole_websocket_server $serv , $fd , $reactorId ){

        call_user_func_array( $this->closeCallback ,[ $serv , $fd , $reactorId ]);

    }

    /**
     * 在task_worker进程内被调用。worker进程可以使用swoole_server_task函数向task_worker进程投递新的任务。当前的Task进程在调用onTask回调函数时会将进程状态切换为忙碌，这时将不再接收新的Task，当onTask函数返回时会将进程状态切换为空闲然后继续接收新的Task。
     * @param $serv  swoole_websocket_server 服务对象
     * @param $task_id int 任务id，由swoole扩展内自动生成，用于区分不同的任务。$task_id和$src_worker_id组合起来才是全局唯一的，不同的worker进程投递的任务ID可能会有相同
     * @param $src_worker_id int 来自于哪个worker进程
     * @param $data mixed 任务的内容
     */
    public function onTask(swoole_server $serv,  $task_id,  $src_worker_id,  $data){

        call_user_func_array( $this->taskCallback , [ $serv, $task_id, $src_worker_id, $data ]);

//        sleep(10);
//        onTask函数中 return字符串，表示将此内容返回给worker进程。worker进程中会触发onFinish函数，表示投递的task已完成。
//        return "task {$src_worker_id}-{$task_id} success";
    }

    /**
     * 当worker进程投递的任务在task_worker中完成时，task进程会通过swoole_server->finish()方法将任务处理的结果发送给worker进程。
     * @param $serv  swoole_websocket_server 服务对象
     * @param $task_id int  任务id
     * @param $data string  task任务处理的结果内容
     * task进程的onTask事件中没有调用finish方法或者return结果，worker进程不会触发onFinish
    执行onFinish逻辑的worker进程与下发task任务的worker进程是同一个进程
     */
    public function onFinish(swoole_server $serv,  $task_id,  $data){

        call_user_func_array( $this->finishCallback ,[ $serv,$task_id,$data]);
//        echo $data;
//        return $data;
    }

    public function onRequest( $request, $response ){
        call_user_func_array( $this->runApp, [ $request, $response ]);
    }

    public function onWorkerStart( $server,  $worker_id ){
        call_user_func_array( $this->workStartCallback , [$server,  $worker_id]);
    }
}
```

起服务和回调设置：
```php
   class SwooleController extends BasicController{

       public $host;

       public $port;

       public  $swoole_config=[];

       public static $table;


       public function actionStart(){

           $config = include __DIR__ . '/../config/console.php';

           if( isset($config['swoole']['log_file']) ) $this->swoole_config['log_file'] = $config['swoole']['log_file'];

           if( isset($config['swoole']['pid_file']) ) $this->swoole_config['pid_file'] = $config['swoole']['pid_file'];

           $this->swoole_config = array_merge(
               [
                   'document_root' => $config['swoole']['document_root'],
                   'enable_static_handler'     => true,
   //                'daemonize'=>1,
                   'worker_num'=>4,
                   'max_request'=>2000,
   //            'task_worker_num'=>100,
                   //检查死链接  使用操作系统提供的keepalive机制来踢掉死链接
                   'open_tcp_keepalive'=>1,
                   'tcp_keepidle'=> 1*60,     //连接在n秒内没有数据请求，将开始对此连接进行探测
                   'tcp_keepcount' => 3,       //探测的次数，超过次数后将close此连接
                   'tcp_keepinterval' => 0.5*60,     //探测的间隔时间，单位秒

                   //swoole实现的心跳机制，只要客户端超过一定时间没发送数据，不管这个连接是不是死链接，都会关闭这个连接
   //            'heartbeat_check_interval' => 10*60,        //每m秒侦测一次心跳
   //            'heartbeat_idle_time' => 30*60,            //一个TCP连接如果在n秒内未向服务器端发送数据，将会被切断
               ],$this->swoole_config
           );

           $this->host = $config['swoole']['host'];
           $this->port = $config['swoole']['port'];
           $swooleServer = new WsServer(  $this->host,$this->port,$config['swoole']['mode'],$config['swoole']['socketType'],$this->swoole_config,$config);

           //连接信息保存到swoole_table
           self::$table = new \swoole_table(10);
           self::$table->column('username',\Swoole\Table::TYPE_STRING, 10);
           self::$table->column('avatar',\Swoole\Table::TYPE_STRING, 255);
           self::$table->column('msg',\Swoole\Table::TYPE_STRING, 255);
           self::$table->column('fd',\Swoole\Table::TYPE_INT, 6);
           self::$table->create();

           $swooleServer->openCallback = function( $server , $request ){
               echo "server handshake with fd={$request->fd}\n";
           };

           $swooleServer->runApp = function( $request , $response ) use($config,$swooleServer){

               //全局变量设置及app.log
               $this->globalParam( $request );
               $_SERVER['SERVER_SWOOLE'] = $swooleServer;

               //记录日志
               $apiData = $_SERVER;
               unset($apiData['SERVER_SWOOLE']);
               Common::addLog( $config['log'] , ($apiData) );

               //解析路由
               $r = $_GET['r'];
               $r = $r?:( isset($config['defaultRoute'])?$config['defaultRoute']:'index/index');
               $params = explode('/',$r);
               $controller = __DIR__.'/../controllers/'.ucfirst($params[0]).'Controller.php';

               $result = '';
               if( file_exists( $controller ) ){
                   require_once $controller;
                   $class = new ReflectionClass(ucfirst($params[0]).'Controller');
                   if( $class->hasMethod( 'action'.ucfirst($params[1]) ) ){
                       $instance  = $class->newInstanceArgs();
                       $method = $class->getmethod('action'.ucfirst($params[1])); // 获取类中方法
                       ob_start();
                       $method->invoke($instance);    // 执行方法
                       $result = ob_get_contents();
                       ob_clean();
                   }else{
                       $result = 'NOT FOUND!';
                   }
               }else{
                   $result = "$controller not exist!";
               }

               $response->end( $result );
           };

           $swooleServer->workStartCallback = function( $server,  $worker_id ){

           };

           $swooleServer->taskCallback = function( $server , $request ){
               //发送通知或者短信、邮件等

           };

           $swooleServer->finishCallback = function( $serv,  $task_id,  $data ){

   //            return $data;
           };

           $swooleServer->messageCallback = function( $server,  $iframe  ){
               //记录客户端信息
               echo "Client connection fd {$iframe->fd} ".PHP_EOL;

               $data = json_decode( $iframe->data ,1 );

               if( !empty($data['token']) ){
                   if( $data['token']== 'simplechat_open' ){
                       if( !self::$table->exist($iframe->fd) ){
                           $user = array_merge($data,['fd'=>$iframe->fd]);
                           self::$table->set($iframe->fd,$user);

                           //发送连接用户信息
                           foreach (self::$table as $v){
                               if($v['fd']!=$iframe->fd){
                                   $pushData = array_merge($user,['action'=>'connect']);
                                   $server->push($v['fd'],json_encode($pushData));
                               }
                           }
                       }

                   }

                   if( $data['token']=='simplechat' ){
                       //查询所有连接用户，分发消息

                       foreach (self::$table as $v){
                           if($v['fd']!=$iframe->fd){
                               $pushData = ['username'=>$data['username'],'avatar'=>$data['avatar'],'time'=>date('H:i'),'data'=>$data['data'],'action'=>'send'];
                               $server->push($v['fd'],json_encode($pushData));
                           }
                       }
                   }
               }

               //接受消息，对消息进行解析，发送给组内人其他人

           };

           $swooleServer->closeCallback = function(  $server,  $fd,  $reactorId ){

               if(  self::$table->exist($fd) ){
                   //退出房间处理
                   self::$table->del($fd);
                   foreach (self::$table as $v){
                       $pushData = ['fd'=>$fd,'username'=>'','avatar'=>'','time'=>date('H:i'),'data'=>'','action'=>'remove'];
                       $server->push($v['fd'],json_encode($pushData));
                   }
               }

               echo  "Client close fd {$fd}".PHP_EOL;
           };

           $this->stdout("server is running, listening {$this->host}:{$this->port}" . PHP_EOL);
           $swooleServer->run();
       }


       public function actionStop(){
           $r = $this->sendSignal( SIGTERM );
           if( $r ){
               $this->stdout("server is stopped, stop listening {$this->host}:{$this->port}" . PHP_EOL);
           }
       }

       public function actionRestart(){
           $this->sendSignal(SIGTERM);     //向主进程发送SIGTERM实现关闭服务器
           $this->actionStart();
       }

       public function actionReload(){
           $this->sendSignal(SIGUSR1);   //向主进程/管理进程发送SIGUSR1信号，将平稳地restart所有Worker进程
       }

   }
```

起了服务，客户端就可以连接通信了。

# 心跳检测
起了半天后服务常会断掉，查看监听端口进程状态，服务器输入：
```shell
$ netstat -anp |grep 9501
```
发现大量CLOSE_WAIT状态，常用状态有 ESTABLISHED 表示正在通信，TIME_WAIT 表示主动关闭，CLOSE_WAIT 表示被动关闭。

TIME_WAIT和CLOSE_WAIT两种状态如果一直被保持，意味着对应数目的通道就一直被占用，且“占着茅坑不使劲”，一旦句柄数达到上限，新的请求就无法处理。而且因为swoole是master-worker模式，
基本上http、tcp通信都是在worker进程，CLOSE_WAIT一直在，子进程将一直无法释放，随着时间的推移CLOSE_WAIT状态的进程越来越多，阻碍新的连接进来，websocket服务不可用。

> 主动关闭 和 被动关闭
TCP关闭 四次握手过程如下：

![image](https://raw.githubusercontent.com/WalkingSun/WindBlog/gh-pages/images/blog/TIM截图20190125111501.jpg)

挥手流程：
1. 客户端发起一个断开请求，进入 FIN-WAIT 状态
2. 服务端确认断开请求
3. 服务端立即发送一个断开请求，进入 CLOSE-WAIT 状态
4. 客户端确认服务端断开请求，进入 TIME-WAIT 状态


由此我们看到CLOSE-WAIT 状态，TIME-WAIT 状态 产生的过程，产生的原因是复杂的，比如说网络通信中断、用户手机网络切换wifi网络、网络通信丢包等，故此tcp挥手过程会出现中断，继而
产生这些关闭状态。

为了解决这些占用连接数的异常连接，需要检测连接是否是活动的，对于死连接我们需要关闭它。

- 对于TIME-WAIT状态





所以需要做心跳检测，及时将这些死链删除，查看了swoole文档，有两种方式：

-


# 系统监控及优化



# 思考




# 参考：

https://juejin.im/post/5c3b21e4e51d455231347349




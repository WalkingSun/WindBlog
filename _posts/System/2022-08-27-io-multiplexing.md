---
layout: blog
title: IO多路复用
categories: [system,IO]
description:
keywords: 多路复用
---

#  IO多路复用
**IO multiplexing** IO多路复用： 通过一种机制，**一个进程**可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。

select/epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。

应用：适用于针对**大量的io请求**的情况，对于服务器必须在同时处理来自客户端的大量的io操作的时候，就非常适合

与多进程和多线程技术相比，I/O多路复用技术的最大优势就是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。

目前支持I/O多路复用的系统调用有select, pselect, poll, epoll, 但他们 本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是 阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。

## select
基本原理：
select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。

### **select优点**

　　1. 跨平台。（几乎所有的平台都支持）

　　2. 时间精度高。（ns级别）
### **select缺点**

　　1. **最大限制：**单个进程能够监视的文件描述符的数量存在最大限制。(基于数组存储的赶脚)

　　　　一般来说这个数目和系统内存关系很大，具体数目可以cat /proc/sys/fs/file-max察看。它由FD_SETSIZE设置，32位机默认是1024个。64位机默认是2048.

　　2.**时间复杂度：** 对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低，时间复杂度O(n)。

 　　当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度，不管哪个Socket是活跃的，都遍历一遍。这会浪费很多CPU时间。

　　它仅仅知道有I/O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以 **select具有O(n)的无差别轮询复杂度**，同时处理的流越多，无差别轮询时间就越长。

　　3.  **内存拷贝：** 需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大。

## epllo
epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的拷贝只需要一次。

epoll有两大特点：

　　　　1. **边缘触发**，它只告诉进程哪些fd刚刚变为就绪态，并且只会通知一次。

　　　　2. **事件驱动，**每个事件关联上fd，使用事件就绪通知方式，通过 epoll_ctl 注册 fd，一旦该fd就绪，内核就会采用 callback 的回调机制来激活该fd，epoll_wait 便可以收到通知。

### **epoll优点**

　　1. **没有最大连接数的限制**。（基于 红黑树+双链表 来存储的:1G的内存上能监听约10万个端口）

　　2. **时间复杂度低：** 边缘触发和事件驱动，监听回调，时间复杂度O(1)。

　　　　只有活跃可用的fd才会调用callback函数；即epoll最大的优点就在于它只管“活跃”的连接，而跟连接总数无关，因此实际网络环境中，Epoll的效率就会远远高于select和poll。

　　3. **内存拷贝：**利用mmap()文件映射内存加速与内核空间的消息传递，减少拷贝开销。

### **epoll缺点**

　　1. 依赖于操作系统：Lunix
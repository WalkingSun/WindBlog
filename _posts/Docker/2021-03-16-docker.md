---
layout: blog
title: Docker应用【draft】
categories: [docker, composer]
description: docker实际运用中的记录
keywords: docker, composer
cnblogsClass: \[Markdown\],\[随笔分类\]服务器,\[随笔分类\]容器
oschinaClass: \[Markdown\],服务器,日常记录
csdnClass: \[Markdown\]
163Class: \[Markdown\]
51ctoClass: \[Markdown\]
chinaunixClass: \[Markdown\]
sinaClass: \[Markdown\]
---

# 简介

Docker作为时下最火热的开源应用容器引擎。虚拟化在硬件级别隔离应用，能够提供更好的资源隔离性，但资源利用率比较低；而 Docker 是在操作系统上进行资源隔离，资源消耗低，能够快速启动，非常适合在一台主机上部署大量隔离环境的应用程序。

**Docker 将应用程序所需要的所有依赖、配置和环境变量打包成镜像，为应用程序提供运行环境。**

Docker 中存在 3 个非常重要的核心概念：

- 镜像（Image）

- 容器（Container）

- 仓库（Repository）

镜像是由多个镜像层叠加 而成的文件系统，其底层为 UnionFS 与 AUFS 文件联合系统， 这是一种分层、支持通过一层一层叠加的方式集成的轻量级且高性能文件系统。 镜像是一个只读的模板，我们可以在一个基础镜像上进行叠加，制作出多种多样不同的镜像。

容器通过镜像启动，是镜像的运行实例，一个镜像可以启动多个容器。容器之间相互隔离，它运行并隔离应用。容器可以被创建、运行、停止、删除、暂停和重启。我们可以简单将容器理解为为应用程序提供沙箱运行环境的 Linux 操作系统。

仓库是管理和存储镜像的地方，分为公有仓库和私有仓库。目前最常用的公有仓库为官方的 Docker Hub，其内提供了大量优质的官方镜像。但由于国内网络的问题，很难直接从官方的 Docker Hub 中拉取镜像，这种情况下我推荐你使用阿里云或者网易云的镜像仓库

# 缘由

容器打包成镜像，一次生成多次部署，容器间相互隔离，即使某个容器出现问题也不会影响到其他容器。

场景应用：

- 微服务架构，每个服务相互独立开发、部署及运维；
- 敏捷开发，模块划分细，易于扩展维护，能够独立部署；

# 应用

项目环境部署一般采用dockerfile来做一些自定义的操作，比如工作目录、配置、环境变量设置等，生成镜像文件，执行部署操作。

```shell
docker run -itd --name redis-5.0 -p 6379:6379 redis:5.0 
```

- -d 选项指定容器以后台方式运行，启动后返回容器的 ID；

- -i 选项让容器的标准输入保持打开，而 -t 选项让 Docker 分配一个伪终端并绑定到容器的标准输入上，这两个选项一般配合使用；

- --name 指令用以指定容器名，要求每个容器都不一样；

- -p 指令将容器的 6379 端口映射到宿主机的 6379 端口，在外部我们可以直接通过宿主机6379 端口访问 Redis。

## 操作
安装docker desktop : brew install --cask docker
```json
{
  "insecure-registries": [
    "harbor-reg.km.com"
  ],
  //  "builder": {
  //   "gc": {
  //     "defaultKeepStorage": "20GB",
  //     "enabled": true
  //   }
  // },
  "debug": true,
  "experimental": false,
  "registry-mirrors": [
    "https://reg-mirror.qiniu.com",
    "https://hub-mirror.c.163.com"
  ]
}
```

- 清理未被使用的景象
docker image prune


# 网络
## 访问主机
容器中可以通过host.docker.internal来访问主机

# 查询容器信息
## 查看停止的容器
```
docker ps -a |grep Exited |awk '{print $1}' 
```
## 删除已经停止的容器
```
docker rm $(docker ps -a |grep Exited |awk '{print $1}' )
```
## 清除镜像
```
docker image prune -a # 清除none 且没有跟容器关联的镜像
```
## docker inspcet
查询信息，包括运行情况、存贮位置、配置参数、网络设置等。

- 查询容器的运行状态
```
docker inspect -f {{.State.Status}} 【容器】
```

- 查询容器的IP
```
docker inspect  -f {{.NetworkSettings.IPAddress}} 【容器】
```

## 查询容器日志信息
docker logs 【容器】

-f 实时打印最新的日志

## docker stats 实时查看容器所占的系统资源
如CPU使用率、内存、网络、磁盘开销

# 容器内部命令
原生方式登入docker exec
```
docker exec + 容器名 +容器内执行的命令
```
比如查询容器php的所有进程：
```
docker exec php7-dev ps -ef
```

容器内连续执行多条命令，可以加上 “-it”参数，相当于以root身份登入容器内，可连续执行命令，执行exit退出。
```
docker exec -it php7-dev /bin/bash
```

# 多容器管理
多个容器有数据交互，依赖，启动方式就必须有先后，如：
```
# db容器优先于WordPress启动
docker start db docker start WordPress
```

